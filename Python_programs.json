[
    {
        "name": "Breadth-First Search",
        "algorithm": "Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the root (or an arbitrary node) and explores all of the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.",
        "code": "from collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        vertex = queue.popleft()\n        print(vertex, end=' ')\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n# Example usage\ngraph = {}\nnum_nodes = int(input('Enter number of nodes: '))\nfor _ in range(num_nodes):\n    node = input('Enter node: ')\n    neighbors = input(f'Enter neighbors for node {node} (comma-separated): ').split(',')\n    graph[node] = [n.strip() for n in neighbors]\nstart_node = input('Enter starting node: ')\nbfs(graph, start_node)",
        "description": "Performs a Breadth-First Search on a graph and prints each visited node."
    },
    {
        "name": "Depth-First Search",
        "algorithm": "Depth-First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.",
        "code": "def dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    print(start, end=' ')\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n\n# Example usage\ngraph = {}\nnum_nodes = int(input('Enter number of nodes: '))\nfor _ in range(num_nodes):\n    node = input('Enter node: ')\n    neighbors = input(f'Enter neighbors for node {node} (comma-separated): ').split(',')\n    graph[node] = [n.strip() for n in neighbors]\nstart_node = input('Enter starting node: ')\ndfs(graph, start_node)",
        "description": "Performs a Depth-First Search on a graph and prints each visited node."
    },
    {
        "name": "Matrix Multiplication",
        "algorithm": "Matrix Multiplication is an operation that takes two matrices and produces a matrix. For matrix A of size m×n and matrix B of size n×p, the resulting matrix C will have size m×p. The value at C[i][j] is the dot product of the ith row of A and the jth column of B.",
        "code": "def matrix_multiply(A, B):\n    result = [[0 for _ in range(len(B[0]))] for _ in range(len(A))]\n    for i in range(len(A)):\n        for j in range(len(B[0])):\n            for k in range(len(B)):\n                result[i][j] += A[i][k] * B[k][j]\n    return result\n\n# Example usage\nA = []\nB = []\nm1, n1 = map(int, input('Enter dimensions of matrix A (rows cols): ').split())\nm2, p2 = map(int, input('Enter dimensions of matrix B (rows cols): ').split())\nprint(f'Enter elements for matrix A ({m1}x{n1}):')\nfor i in range(m1):\n    A.append(list(map(int, input().split())))\nprint(f'Enter elements for matrix B ({n1}x{p2}):')\nfor i in range(n1):\n    B.append(list(map(int, input().split())))\nresult = matrix_multiply(A, B)\nprint('Resulting matrix:')\nfor row in result:\n    print(' '.join(map(str, row)))",
        "description": "Multiplies two matrices and returns the resulting matrix."
    },
    {
        "name": "Dijkstra's Algorithm",
        "algorithm": "Dijkstra's Algorithm finds the shortest path between nodes in a graph, which may represent, for example, road networks. It works by iteratively selecting the node with the smallest distance, updating the distances of its neighbors, and repeating until all nodes have been visited.",
        "code": "import heapq\n\ndef dijkstra(graph, start):\n    queue = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    return distances\n\n# Example usage\ngraph = {}\nnum_nodes = int(input('Enter number of nodes: '))\nfor _ in range(num_nodes):\n    node = input('Enter node: ')\n    graph[node] = {}\n    num_neighbors = int(input(f'Enter number of neighbors for node {node}: '))\n    for _ in range(num_neighbors):\n        neighbor, weight = input('Enter neighbor and weight (comma-separated): ').split(',')\n        graph[node][neighbor.strip()] = int(weight)\nstart_node = input('Enter starting node: ')\ndistances = dijkstra(graph, start_node)\nprint('Distances from start node:')\nfor node, distance in distances.items():\n    print(f'{node}: {distance}')",
        "description": "Finds the shortest path from a start node to all other nodes in a graph using Dijkstra's Algorithm."
    },
    {
        "name": "8-Puzzle Problem",
        "algorithm": "The 8-Puzzle Problem is a sliding puzzle that consists of a 3x3 grid with 8 tiles and one empty space. The objective is to move the tiles around to reach a goal configuration from a given initial configuration.",
        "code": "from collections import deque\nimport copy\n\ndef is_solvable(puzzle):\n    one_d_puzzle = [tile for row in puzzle for tile in row if tile != 0]\n    inversions = 0\n    for i in range(len(one_d_puzzle)):\n        for j in range(i + 1, len(one_d_puzzle)):\n            if one_d_puzzle[i] > one_d_puzzle[j]:\n                inversions += 1\n    return inversions % 2 == 0\n\ndef print_puzzle(puzzle):\n    for row in puzzle:\n        print(' '.join(map(str, row)))\n\ndef solve_puzzle(start, goal):\n    def get_blank_position(puzzle):\n        for i, row in enumerate(puzzle):\n            if 0 in row:\n                return i, row.index(0)\n\n    def get_neighbors(puzzle):\n        neighbors = []\n        x, y = get_blank_position(puzzle)\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 3 and 0 <= ny < 3:\n                new_puzzle = copy.deepcopy(puzzle)\n                new_puzzle[x][y], new_puzzle[nx][ny] = new_puzzle[nx][ny], new_puzzle[x][y]\n                neighbors.append(new_puzzle)\n        return neighbors\n\n    def bfs(start):\n        if not is_solvable(start):\n            print('The puzzle is not solvable.')\n            return\n        queue = deque([(start, [])])\n        visited = set()\n        visited.add(tuple(map(tuple, start)))\n        while queue:\n            current_puzzle, path = queue.popleft()\n            if current_puzzle == goal:\n                print('Solution found!')\n                for step in path:\n                    print_puzzle(step)\n                    print()\n                return\n            for neighbor in get_neighbors(current_puzzle):\n                neighbor_tuple = tuple(map(tuple, neighbor))\n                if neighbor_tuple not in visited:\n                    visited.add(neighbor_tuple)\n                    queue.append((neighbor, path + [current_puzzle]))\n        print('No solution found.')\n\n# Example usage\nprint('Enter the initial puzzle state (use 0 for the blank space):')\nstart = [list(map(int, input().split())) for _ in range(3)]\ngoal = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\nsolve_puzzle(start, goal)",
        "description": "Solves the 8-Puzzle problem by finding a sequence of moves to reach the goal configuration."
    },
    {
        "name": "Water Jug Problem",
        "algorithm": "The Water Jug Problem involves two jugs with different capacities and the goal is to measure out a specific amount of water using the jugs. This is a classic problem in AI and problem-solving that can be approached using search algorithms.",
        "code": "def water_jug_solver(capacity_x, capacity_y, target):\n    from collections import deque\n    visited = set()\n    queue = deque([(0, 0)])\n    while queue:\n        x, y = queue.popleft()\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        print(f'Jug X: {x}, Jug Y: {y}')\n        if x == target or y == target:\n            print('Solution found!')\n            return\n        # Fill Jug X\n        queue.append((capacity_x, y))\n        # Fill Jug Y\n        queue.append((x, capacity_y))\n        # Empty Jug X\n        queue.append((0, y))\n        # Empty Jug Y\n        queue.append((x, 0))\n        # Pour from Jug X to Jug Y\n        pour_to_y = min(x, capacity_y - y)\n        queue.append((x - pour_to_y, y + pour_to_y))\n        # Pour from Jug Y to Jug X\n        pour_to_x = min(y, capacity_x - x)\n        queue.append((x + pour_to_x, y - pour_to_x))\n\n# Example usage\ncapacity_x = int(input('Enter the capacity of Jug X: '))\ncapacity_y = int(input('Enter the capacity of Jug Y: '))\ntarget = int(input('Enter the target amount of water: '))\nwater_jug_solver(capacity_x, capacity_y, target)",
        "description": "Solves the Water Jug problem using a breadth-first search approach to find a sequence of steps to measure out a specific amount of water."
    }
]
