[
    {
        "name": "Breadth-First Search",
        "algorithm": "Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the root (or an arbitrary node) and explores all of the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int vertex;\n    struct Node* next;\n};\n\nstruct Graph {\n    int numVertices;\n    struct Node** adjLists;\n    int* visited;\n};\n\nvoid bfs(struct Graph* graph, int startVertex) {\n    struct Node* adjList;\n    struct Node* temp;\n    int* queue = malloc(graph->numVertices * sizeof(int));\n    int front = 0, rear = 0;\n    graph->visited[startVertex] = 1;\n    queue[rear++] = startVertex;\n    while (front < rear) {\n        int currentVertex = queue[front++];\n        printf(\"%d \", currentVertex);\n        adjList = graph->adjLists[currentVertex];\n        while (adjList != NULL) {\n            int adjVertex = adjList->vertex;\n            if (graph->visited[adjVertex] == 0) {\n                graph->visited[adjVertex] = 1;\n                queue[rear++] = adjVertex;\n            }\n            adjList = adjList->next;\n        }\n    }\n    free(queue);\n}\n\n// Additional code for creating graph and adding edges\n",
        "description": "Implements Breadth-First Search on a graph using a queue and prints each visited node."
    },
    {
        "name": "Depth-First Search",
        "algorithm": "Depth-First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int vertex;\n    struct Node* next;\n};\n\nstruct Graph {\n    int numVertices;\n    struct Node** adjLists;\n    int* visited;\n};\n\nvoid dfs(struct Graph* graph, int vertex) {\n    struct Node* adjList = graph->adjLists[vertex];\n    struct Node* temp = adjList;\n    graph->visited[vertex] = 1;\n    printf(\"%d \", vertex);\n    while (temp != NULL) {\n        int connectedVertex = temp->vertex;\n        if (graph->visited[connectedVertex] == 0) {\n            dfs(graph, connectedVertex);\n        }\n        temp = temp->next;\n    }\n}\n\n// Additional code for creating graph and adding edges\n",
        "description": "Implements Depth-First Search on a graph using recursion and prints each visited node."
    },
    {
        "name": "Matrix Multiplication",
        "algorithm": "Matrix Multiplication is an operation that takes two matrices and produces a matrix. For matrix A of size m×n and matrix B of size n×p, the resulting matrix C will have size m×p. The value at C[i][j] is the dot product of the ith row of A and the jth column of B.",
        "code": "#include <stdio.h>\n\nvoid multiply(int A[2][2], int B[2][2], int C[2][2]) {\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            C[i][j] = 0;\n            for (int k = 0; k < 2; k++) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\nint main() {\n    int A[2][2] = {{1, 2}, {3, 4}};\n    int B[2][2] = {{5, 6}, {7, 8}};\n    int C[2][2];\n    multiply(A, B, C);\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            printf(\"%d \", C[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
        "description": "Multiplies two matrices and prints the resulting matrix."
    }
]
