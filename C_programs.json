[
    {
        "name": "Breadth-First Search",
        "algorithm": "Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the root (or an arbitrary node) and explores all of the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int vertex;\n    struct Node* next;\n};\n\nstruct Graph {\n    int numVertices;\n    struct Node** adjLists;\n    int* visited;\n};\n\nvoid bfs(struct Graph* graph, int startVertex) {\n    struct Node* adjList;\n    struct Node* temp;\n    int* queue = malloc(graph->numVertices * sizeof(int));\n    int front = 0, rear = 0;\n    graph->visited[startVertex] = 1;\n    queue[rear++] = startVertex;\n    while (front < rear) {\n        int currentVertex = queue[front++];\n        printf(\"%d \", currentVertex);\n        adjList = graph->adjLists[currentVertex];\n        while (adjList != NULL) {\n            int adjVertex = adjList->vertex;\n            if (graph->visited[adjVertex] == 0) {\n                graph->visited[adjVertex] = 1;\n                queue[rear++] = adjVertex;\n            }\n            adjList = adjList->next;\n        }\n    }\n    free(queue);\n}\n\n// Additional code for creating graph and adding edges\n",
        "description": "Implements Breadth-First Search on a graph using a queue and prints each visited node."
    },
    {
        "name": "Depth-First Search",
        "algorithm": "Depth-First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int vertex;\n    struct Node* next;\n};\n\nstruct Graph {\n    int numVertices;\n    struct Node** adjLists;\n    int* visited;\n};\n\nvoid dfs(struct Graph* graph, int vertex) {\n    struct Node* adjList = graph->adjLists[vertex];\n    struct Node* temp = adjList;\n    graph->visited[vertex] = 1;\n    printf(\"%d \", vertex);\n    while (temp != NULL) {\n        int connectedVertex = temp->vertex;\n        if (graph->visited[connectedVertex] == 0) {\n            dfs(graph, connectedVertex);\n        }\n        temp = temp->next;\n    }\n}\n\n// Additional code for creating graph and adding edges\n",
        "description": "Implements Depth-First Search on a graph using recursion and prints each visited node."
    },
    {
        "name": "Matrix Multiplication",
        "algorithm": "Matrix Multiplication is an operation that takes two matrices and produces a matrix. For matrix A of size m×n and matrix B of size n×p, the resulting matrix C will have size m×p. The value at C[i][j] is the dot product of the ith row of A and the jth column of B.",
        "code": "#include <stdio.h>\n\nvoid multiply(int A[2][2], int B[2][2], int C[2][2]) {\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            C[i][j] = 0;\n            for (int k = 0; k < 2; k++) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\nint main() {\n    int A[2][2] = {{1, 2}, {3, 4}};\n    int B[2][2] = {{5, 6}, {7, 8}};\n    int C[2][2];\n    multiply(A, B, C);\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            printf(\"%d \", C[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
        "description": "Multiplies two matrices and prints the resulting matrix."
    },
    {
        "name": "Dijkstra's Algorithm",
        "algorithm": "Dijkstra's Algorithm finds the shortest path between nodes in a graph. It uses a priority queue to continuously select the closest node to the start node and updates the shortest path to each neighboring node.",
        "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define V 9\n\nint minDistance(int dist[], bool sptSet[]) {\n    int min = INT_MAX, min_index;\n    for (int v = 0; v < V; v++) {\n        if (!sptSet[v] && dist[v] <= min) {\n            min = dist[v];\n            min_index = v;\n        }\n    }\n    return min_index;\n}\n\nvoid dijkstra(int graph[V][V], int start) {\n    int dist[V];\n    bool sptSet[V];\n\n    for (int i = 0; i < V; i++) {\n        dist[i] = INT_MAX;\n        sptSet[i] = false;\n    }\n    dist[start] = 0;\n\n    for (int count = 0; count < V - 1; count++) {\n        int u = minDistance(dist, sptSet);\n        sptSet[u] = true;\n\n        for (int v = 0; v < V; v++) {\n            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {\n                dist[v] = dist[u] + graph[u][v];\n            }\n        }\n    }\n\n    printf(\"Vertex Distance from Source\\n\");\n    for (int i = 0; i < V; i++) {\n        printf(\"%d \\t\\t %d\\n\", i, dist[i]);\n    }\n}\n\nint main() {\n    int graph[V][V] = {\n        {0, 4, 0, 0, 0, 0, 0, 8, 0},\n        {4, 0, 8, 0, 0, 0, 0, 11, 0},\n        {0, 8, 0, 7, 0, 4, 0, 0, 2},\n        {0, 0, 7, 0, 9, 14, 0, 0, 0},\n        {0, 0, 0, 9, 0, 10, 0, 0, 0},\n        {0, 0, 4, 14, 10, 0, 2, 0, 0},\n        {0, 0, 0, 0, 0, 2, 0, 1, 6},\n        {8, 11, 0, 0, 0, 0, 1, 0, 7},\n        {0, 0, 2, 0, 0, 0, 6, 7, 0}\n    };\n\n    dijkstra(graph, 0);\n\n    return 0;\n}",
        "description": "Finds the shortest path from a start node to all other nodes in a graph using Dijkstra's Algorithm."
    },
    {
        "name": "Water Jug Problem",
        "algorithm": "The Water Jug Problem involves measuring a specific amount of water using two jugs with different capacities. It can be solved using a breadth-first search (BFS) algorithm to explore all possible states until the target measurement is reached.",
        "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nstruct State {\n    int jug1, jug2;\n    State(int j1, int j2) : jug1(j1), jug2(j2) {}\n    bool operator<(const State& other) const {\n        return jug1 < other.jug1 || (jug1 == other.jug1 && jug2 < other.jug2);\n    }\n};\n\nbool bfs(int jug1Capacity, int jug2Capacity, int target) {\n    queue<State> q;\n    set<State> visited;\n    q.push(State(0, 0));\n    visited.insert(State(0, 0));\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.jug1 == target || current.jug2 == target) {\n            return true;\n        }\n\n        vector<State> nextStates;\n        nextStates.push_back(State(jug1Capacity, current.jug2)); // Fill jug1\n        nextStates.push_back(State(current.jug1, jug2Capacity)); // Fill jug2\n        nextStates.push_back(State(0, current.jug2)); // Empty jug1\n        nextStates.push_back(State(current.jug1, 0)); // Empty jug2\n        nextStates.push_back(State(current.jug1 - min(current.jug1, jug2Capacity - current.jug2), current.jug2 + min(current.jug1, jug2Capacity - current.jug2))); // Pour jug1 into jug2\n        nextStates.push_back(State(current.jug1 + min(current.jug2, jug1Capacity - current.jug1), current.jug2 - min(current.jug2, jug1Capacity - current.jug1))); // Pour jug2 into jug1\n\n        for (const State& next : nextStates) {\n            if (visited.find(next) == visited.end()) {\n                visited.insert(next);\n                q.push(next);\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int jug1Capacity = 4;\n    int jug2Capacity = 3;\n    int target = 2;\n\n    if (bfs(jug1Capacity, jug2Capacity, target)) {\n        printf(\"Target amount can be measured.\");\n    } else {\n        printf(\"Target amount cannot be measured.\");\n    }\n\n    return 0;\n}",
        "description": "Solves the Water Jug Problem using a breadth-first search algorithm to find a way to measure a specific amount of water."
    }
]
