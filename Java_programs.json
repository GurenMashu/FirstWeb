[
    {
        "name": "Breadth-First Search",
        "algorithm": "Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the root (or an arbitrary node) and explores all of the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.",
        "code": "import java.util.*;\n\nclass BFS {\n    private Map<Character, List<Character>> graph;\n\n    public BFS() {\n        graph = new HashMap<>();\n    }\n\n    public void addEdge(char v, char w) {\n        graph.putIfAbsent(v, new LinkedList<>());\n        graph.get(v).add(w);\n    }\n\n    public void bfs(char start) {\n        Set<Character> visited = new HashSet<>();\n        Queue<Character> queue = new LinkedList<>();\n        visited.add(start);\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            char vertex = queue.poll();\n            System.out.print(vertex + \" \");\n            for (char neighbor : graph.get(vertex)) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.add(neighbor);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        BFS bfs = new BFS();\n        bfs.addEdge('A', 'B');\n        bfs.addEdge('A', 'C');\n        bfs.addEdge('B', 'D');\n        bfs.addEdge('B', 'E');\n        bfs.addEdge('C', 'F');\n        bfs.bfs('A');\n    }\n}",
        "description": "Implements Breadth-First Search on a graph using a queue and prints each visited node."
    },
    {
        "name": "Depth-First Search",
        "algorithm": "Depth-First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.",
        "code": "import java.util.*;\n\nclass DFS {\n    private Map<Character, List<Character>> graph;\n\n    public DFS() {\n        graph = new HashMap<>();\n    }\n\n    public void addEdge(char v, char w) {\n        graph.putIfAbsent(v, new LinkedList<>());\n        graph.get(v).add(w);\n    }\n\n    public void dfs(char start, Set<Character> visited) {\n        visited.add(start);\n        System.out.print(start + \" \");\n        for (char neighbor : graph.get(start)) {\n            if (!visited.contains(neighbor)) {\n                dfs(neighbor, visited);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        DFS dfs = new DFS();\n        dfs.addEdge('A', 'B');\n        dfs.addEdge('A', 'C');\n        dfs.addEdge('B', 'D');\n        dfs.addEdge('B', 'E');\n        dfs.addEdge('C', 'F');\n        Set<Character> visited = new HashSet<>();\n        dfs.dfs('A', visited);\n    }\n}",
        "description": "Implements Depth-First Search on a graph using recursion and prints each visited node."
    },
    {
        "name": "Matrix Multiplication",
        "algorithm": "Matrix Multiplication is an operation that takes two matrices and produces a matrix. For matrix A of size m×n and matrix B of size n×p, the resulting matrix C will have size m×p. The value at C[i][j] is the dot product of the ith row of A and the jth column of B.",
        "code": "class MatrixMultiplication {\n    public static int[][] multiply(int[][] A, int[][] B) {\n        int m = A.length;\n        int n = A[0].length;\n        int p = B[0].length;\n        int[][] C = new int[m][p];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < p; j++) {\n                for (int k = 0; k < n; k++) {\n                    C[i][j] += A[i][k] * B[k][j];\n                }\n            }\n        }\n        return C;\n    }\n\n    public static void main(String[] args) {\n        int[][] A = {{1, 2}, {3, 4}};\n        int[][] B = {{5, 6}, {7, 8}};\n        int[][] C = multiply(A, B);\n        for (int i = 0; i < C.length; i++) {\n            for (int j = 0; j < C[0].length; j++) {\n                System.out.print(C[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}",
        "description": "Multiplies two matrices and prints the resulting matrix."
    },
    {
        "name": "Dijkstra's Algorithm",
        "algorithm": "Dijkstra's Algorithm finds the shortest path between nodes in a graph. It uses a priority queue to continuously select the closest node to the start node and updates the shortest path to each neighboring node.",
        "code": "import java.util.*;\n\npublic class Dijkstra {\n    public static Map<String, Integer> dijkstra(Map<String, Map<String, Integer>> graph, String start) {\n        Map<String, Integer> distances = new HashMap<>();\n        PriorityQueue<Map.Entry<String, Integer>> queue = new PriorityQueue<>(Comparator.comparingInt(Map.Entry::getValue));\n\n        for (String node : graph.keySet()) {\n            distances.put(node, Integer.MAX_VALUE);\n        }\n        distances.put(start, 0);\n        queue.add(new AbstractMap.SimpleEntry<>(start, 0));\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll().getKey();\n            int currentDistance = distances.get(current);\n\n            for (Map.Entry<String, Integer> neighbor : graph.get(current).entrySet()) {\n                String next = neighbor.getKey();\n                int weight = neighbor.getValue();\n                int newDistance = currentDistance + weight;\n\n                if (newDistance < distances.get(next)) {\n                    distances.put(next, newDistance);\n                    queue.add(new AbstractMap.SimpleEntry<>(next, newDistance));\n                }\n            }\n        }\n        return distances;\n    }\n\n    public static void main(String[] args) {\n        Map<String, Map<String, Integer>> graph = new HashMap<>();\n        graph.put(\"A\", Map.of(\"B\", 1, \"C\", 4));\n        graph.put(\"B\", Map.of(\"C\", 2, \"D\", 5));\n        graph.put(\"C\", Map.of(\"D\", 1));\n\n        String startNode = \"A\";\n        Map<String, Integer> distances = dijkstra(graph, startNode);\n\n        System.out.println(\"Shortest distances from \" + startNode + \":\");\n        for (Map.Entry<String, Integer> entry : distances.entrySet()) {\n            System.out.println(entry.getKey() + \" : \" + entry.getValue());\n        }\n    }\n}",
        "description": "Finds the shortest path from a start node to all other nodes in a graph using Dijkstra's Algorithm."
    },
    {
        "name": "Water Jug Problem",
        "algorithm": "The Water Jug Problem involves measuring a specific amount of water using two jugs with different capacities. It can be solved using a breadth-first search (BFS) algorithm to explore all possible states until the target measurement is reached.",
        "code": "import java.util.*;\n\npublic class WaterJug {\n    public static void main(String[] args) {\n        int jug1Capacity = 4;\n        int jug2Capacity = 3;\n        int target = 2;\n\n        Set<String> visited = new HashSet<>();\n        Queue<State> queue = new LinkedList<>();\n        queue.add(new State(0, 0));\n        visited.add(\"0,0\");\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.jug1 == target || current.jug2 == target) {\n                System.out.println(\"Target reached: \" + current);\n                return;\n            }\n\n            List<State> nextStates = getNextStates(current, jug1Capacity, jug2Capacity);\n            for (State next : nextStates) {\n                if (!visited.contains(next.toString())) {\n                    visited.add(next.toString());\n                    queue.add(next);\n                }\n            }\n        }\n    }\n\n    private static List<State> getNextStates(State current, int jug1Capacity, int jug2Capacity) {\n        List<State> nextStates = new ArrayList<>();\n\n        // Fill jug1\n        nextStates.add(new State(jug1Capacity, current.jug2));\n        // Fill jug2\n        nextStates.add(new State(current.jug1, jug2Capacity));\n        // Empty jug1\n        nextStates.add(new State(0, current.jug2));\n        // Empty jug2\n        nextStates.add(new State(current.jug1, 0));\n        // Pour jug1 into jug2\n        int pourToJug2 = Math.min(current.jug1, jug2Capacity - current.jug2);\n        nextStates.add(new State(current.jug1 - pourToJug2, current.jug2 + pourToJug2));\n        // Pour jug2 into jug1\n        int pourToJug1 = Math.min(current.jug2, jug1Capacity - current.jug1);\n        nextStates.add(new State(current.jug1 + pourToJug1, current.jug2 - pourToJug1));\n\n        return nextStates;\n    }\n\n    private static class State {\n        int jug1, jug2;\n\n        State(int jug1, int jug2) {\n            this.jug1 = jug1;\n            this.jug2 = jug2;\n        }\n\n        @Override\n        public String toString() {\n            return jug1 + \",\" + jug2;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            State state = (State) obj;\n            return jug1 == state.jug1 && jug2 == state.jug2;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(jug1, jug2);\n        }\n    }\n}",
        "description": "Solves the Water Jug Problem using a breadth-first search algorithm to find a way to measure a specific amount of water."
    }
]
