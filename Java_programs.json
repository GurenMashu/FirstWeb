[
    {
        "name": "Breadth-First Search",
        "algorithm": "Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the root (or an arbitrary node) and explores all of the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.",
        "code": "import java.util.*;\n\nclass BFS {\n    private Map<Character, List<Character>> graph;\n\n    public BFS() {\n        graph = new HashMap<>();\n    }\n\n    public void addEdge(char v, char w) {\n        graph.putIfAbsent(v, new LinkedList<>());\n        graph.get(v).add(w);\n    }\n\n    public void bfs(char start) {\n        Set<Character> visited = new HashSet<>();\n        Queue<Character> queue = new LinkedList<>();\n        visited.add(start);\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            char vertex = queue.poll();\n            System.out.print(vertex + \" \");\n            for (char neighbor : graph.get(vertex)) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.add(neighbor);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        BFS bfs = new BFS();\n        bfs.addEdge('A', 'B');\n        bfs.addEdge('A', 'C');\n        bfs.addEdge('B', 'D');\n        bfs.addEdge('B', 'E');\n        bfs.addEdge('C', 'F');\n        bfs.bfs('A');\n    }\n}",
        "description": "Implements Breadth-First Search on a graph using a queue and prints each visited node."
    },
    {
        "name": "Depth-First Search",
        "algorithm": "Depth-First Search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.",
        "code": "import java.util.*;\n\nclass DFS {\n    private Map<Character, List<Character>> graph;\n\n    public DFS() {\n        graph = new HashMap<>();\n    }\n\n    public void addEdge(char v, char w) {\n        graph.putIfAbsent(v, new LinkedList<>());\n        graph.get(v).add(w);\n    }\n\n    public void dfs(char start, Set<Character> visited) {\n        visited.add(start);\n        System.out.print(start + \" \");\n        for (char neighbor : graph.get(start)) {\n            if (!visited.contains(neighbor)) {\n                dfs(neighbor, visited);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        DFS dfs = new DFS();\n        dfs.addEdge('A', 'B');\n        dfs.addEdge('A', 'C');\n        dfs.addEdge('B', 'D');\n        dfs.addEdge('B', 'E');\n        dfs.addEdge('C', 'F');\n        Set<Character> visited = new HashSet<>();\n        dfs.dfs('A', visited);\n    }\n}",
        "description": "Implements Depth-First Search on a graph using recursion and prints each visited node."
    },
    {
        "name": "Matrix Multiplication",
        "algorithm": "Matrix Multiplication is an operation that takes two matrices and produces a matrix. For matrix A of size m×n and matrix B of size n×p, the resulting matrix C will have size m×p. The value at C[i][j] is the dot product of the ith row of A and the jth column of B.",
        "code": "class MatrixMultiplication {\n    public static int[][] multiply(int[][] A, int[][] B) {\n        int m = A.length;\n        int n = A[0].length;\n        int p = B[0].length;\n        int[][] C = new int[m][p];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < p; j++) {\n                for (int k = 0; k < n; k++) {\n                    C[i][j] += A[i][k] * B[k][j];\n                }\n            }\n        }\n        return C;\n    }\n\n    public static void main(String[] args) {\n        int[][] A = {{1, 2}, {3, 4}};\n        int[][] B = {{5, 6}, {7, 8}};\n        int[][] C = multiply(A, B);\n        for (int i = 0; i < C.length; i++) {\n            for (int j = 0; j < C[0].length; j++) {\n                System.out.print(C[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}",
        "description": "Multiplies two matrices and prints the resulting matrix."
    }
]
